   * [排序](#排序)
      * [比较排序](#比较排序)
         * [冒泡排序](#冒泡排序)
         * [归并排序](#归并排序)
         * [快速排序](#快速排序)
      * [线性排序](#线性排序)
         * [计数排序](#计数排序)
         * [桶排序](#桶排序)
   * [数组 / 双指针](#数组--双指针)
      * [<a href="https://leetcode-cn.com/problems/plus-one/" rel="nofollow">加一</a>](#加一)
      * [<a href="https://leetcode-cn.com/problems/majority-element/" rel="nofollow">多数元素</a>](#多数元素)
      * [<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" rel="nofollow">删除排序数组中的重复项</a>](#删除排序数组中的重复项)
      * [<a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" rel="nofollow">寻找重复数</a>](#寻找重复数)
      * [<a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/" rel="nofollow">两个数组的交集</a>](#两个数组的交集)
      * [<a href="https://leetcode-cn.com/problems/two-sum/" rel="nofollow">两数之和</a>](#两数之和)
      * [<a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" rel="nofollow">两数之和 II</a>](#两数之和-ii)
      * [<a href="https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/" rel="nofollow">两数之和BST</a>](#两数之和bst)
      * [<a href="https://leetcode-cn.com/problems/3sum/" rel="nofollow">三数之和</a>](#三数之和)
      * [<a href="https://leetcode-cn.com/problems/3sum-closest/" rel="nofollow">最接近的三数之和</a>](#最接近的三数之和)
      * [<a href="https://leetcode-cn.com/problems/4sum/" rel="nofollow">四数之和</a>](#四数之和)
      * [<a href="https://leetcode-cn.com/problems/sorted-merge-lcci/" rel="nofollow">合并排序的数组</a>](#合并排序的数组)
   * [二分查找](#二分查找)
      * [<a href="https://leetcode-cn.com/problems/sqrtx/" rel="nofollow">x 的平方根</a>](#x-的平方根)
      * [<a href="https://leetcode-cn.com/problems/powx-n/" rel="nofollow">Pow(x, n)</a>](#powx-n)
      * [<a href="https://leetcode-cn.com/problems/sum-of-square-numbers/" rel="nofollow">平方数之和</a>](#平方数之和)
      * [<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" rel="nofollow">在排序数组中查找元素</a>](#在排序数组中查找元素)
      * [<a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/" rel="nofollow">0～n-1中缺失的数字</a>](#0n-1中缺失的数字)
      * [<a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" rel="nofollow">旋转排序数组中的最小值</a>](#旋转排序数组中的最小值)
      * [<a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/" rel="nofollow">旋转排序数组中的最小值 II</a>](#旋转排序数组中的最小值-ii)
   * [链表](#链表)
      * [<a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/" rel="nofollow">删除节点</a>](#删除节点)
      * [<a href="https://leetcode-cn.com/problems/remove-linked-list-elements/" rel="nofollow">移除链表元素</a>](#移除链表元素)
      * [<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" rel="nofollow">删除排序链表中的重复元素</a>](#删除排序链表中的重复元素)
      * [<a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" rel="nofollow">删除倒数第N个节点</a>](#删除倒数第n个节点)
      * [<a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/" rel="nofollow">中间结点</a>](#中间结点)
      * [<a href="https://leetcode-cn.com/problems/linked-list-cycle/" rel="nofollow">环形链表</a>](#环形链表)
      * [<a href="https://leetcode-cn.com/problems/reverse-linked-list/" rel="nofollow">反转链表</a>](#反转链表)
      * [<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" rel="nofollow">合并两个有序链表</a>](#合并两个有序链表)
      * [<a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" rel="nofollow">合并K个排序链表</a>](#合并k个排序链表)
      * [<a href="https://leetcode-cn.com/problems/sort-list/" rel="nofollow">排序链表</a>](#排序链表)
      * [<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" rel="nofollow">相交链表</a>](#相交链表)
      * [<a href="https://leetcode-cn.com/problems/palindrome-linked-list/" rel="nofollow">回文链表</a>](#回文链表)
      * [<a href="https://leetcode-cn.com/problems/odd-even-linked-list/" rel="nofollow">奇偶链表</a>](#奇偶链表)
      * [<a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/" rel="nofollow">从尾到头打印链表</a>](#从尾到头打印链表)
      * [<a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" rel="nofollow">两两交换链表中的节点</a>](#两两交换链表中的节点)
      * [<a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/" rel="nofollow">复制带随机指针的链表</a>](#复制带随机指针的链表)
      * [<a href="https://leetcode-cn.com/problems/add-two-numbers/" rel="nofollow">两数相加</a>](#两数相加)
      * [<a href="https://leetcode-cn.com/problems/add-two-numbers-ii/" rel="nofollow">两数相加 II</a>](#两数相加-ii)
   * [栈 / 队列](#栈--队列)
      * [<a href="https://leetcode-cn.com/problems/min-stack/" rel="nofollow">最小栈</a>](#最小栈)
      * [<a href="https://leetcode-cn.com/problems/validate-stack-sequences/" rel="nofollow">验证栈序列</a>](#验证栈序列)
      * [<a href="https://leetcode-cn.com/problems/valid-parentheses/" rel="nofollow">有效括号</a>](#有效括号)
      * [<a href="https://leetcode-cn.com/problems/generate-parentheses/" rel="nofollow">括号生成</a>](#括号生成)
      * [<a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/" rel="nofollow">用栈实现队列</a>](#用栈实现队列)
      * [<a href="https://leetcode-cn.com/problems/implement-stack-using-queues/" rel="nofollow">用队列实现栈</a>](#用队列实现栈)
      * [逆波兰表达式求值](#逆波兰表达式求值)
   * [哈希表](#哈希表)
   * [堆 / 优先队列](#堆--优先队列)
      * [<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" rel="nofollow">数组中的第K个最大元素</a>](#数组中的第k个最大元素)
      * [<a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" rel="nofollow">最小的k个数</a>](#最小的k个数)
      * [<a href="https://leetcode-cn.com/problems/top-k-frequent-elements/" rel="nofollow">前 K 个高频元素</a>](#前-k-个高频元素)
   * [二叉树](#二叉树)
      * [顺序遍历](#顺序遍历)
            * [<a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" rel="nofollow">前序遍历</a>](#前序遍历)
            * [<a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" rel="nofollow">中序遍历</a>](#中序遍历)
            * [<a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" rel="nofollow">后序遍历</a>](#后序遍历)
      * [<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" rel="nofollow">前序与中序遍历序列构造二叉树</a>](#前序与中序遍历序列构造二叉树)
      * [<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" rel="nofollow">中序与后序遍历序列构造二叉树</a>](#中序与后序遍历序列构造二叉树)
      * [<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" rel="nofollow">层序遍历</a>](#层序遍历)
      * [<a href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/" rel="nofollow">层平均值</a>](#层平均值)
      * [<a href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/" rel="nofollow">树左下角的值</a>](#树左下角的值)
      * [<a href="https://leetcode-cn.com/problems/invert-binary-tree/" rel="nofollow">翻转二叉树</a>](#翻转二叉树)
      * [<a href="https://leetcode-cn.com/problems/merge-two-binary-trees/" rel="nofollow">合并二叉树</a>](#合并二叉树)
      * [<a href="https://leetcode-cn.com/problems/symmetric-tree/" rel="nofollow">对称二叉树</a>](#对称二叉树)
      * [<a href="https://leetcode-cn.com/problems/subtree-of-another-tree/" rel="nofollow">另一个树的子树</a>](#另一个树的子树)
      * [最大值](#最大值)
      * [<a href="https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/" rel="nofollow">第二小的节点</a>](#第二小的节点)
      * [<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" rel="nofollow">最大深度</a>](#最大深度)
      * [<a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" rel="nofollow">最小深度</a>](#最小深度)
      * [<a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/" rel="nofollow">直径</a>](#直径)
      * [<a href="https://leetcode-cn.com/problems/balanced-binary-tree/" rel="nofollow">平衡二叉树</a>](#平衡二叉树)
      * [<a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/" rel="nofollow">二叉树展开为链表</a>](#二叉树展开为链表)
      * [<a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/" rel="nofollow">和为某一值的路径</a>](#和为某一值的路径)
      * [<a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/" rel="nofollow">完全二叉树的节点个数</a>](#完全二叉树的节点个数)
   * [二叉搜索树](#二叉搜索树)
      * [<a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" rel="nofollow">验证二叉搜索树</a>](#验证二叉搜索树)
      * [<a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/" rel="nofollow">第K小的元素</a>](#第k小的元素)
      * [<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/" rel="nofollow">第k大的元素</a>](#第k大的元素)
      * [<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/" rel="nofollow">BST与双向链表</a>](#bst与双向链表)
      * [<a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/" rel="nofollow">最小绝对差</a>](#最小绝对差)
      * [<a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/" rel="nofollow">BST转换为累加树</a>](#bst转换为累加树)
      * [<a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/" rel="nofollow">有序数组转换为BST</a>](#有序数组转换为bst)
      * [<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/" rel="nofollow">后序遍历序列</a>](#后序遍历序列)
      * [<a href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/" rel="nofollow">修剪二叉搜索树</a>](#修剪二叉搜索树)
      * [<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" rel="nofollow">BST最近公共祖先</a>](#bst最近公共祖先)
      * [<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" rel="nofollow">二叉树最近公共祖先</a>](#二叉树最近公共祖先)
      * [<a href="https://leetcode-cn.com/problems/unique-binary-search-trees/" rel="nofollow">不同的二叉搜索树</a>](#不同的二叉搜索树)
      * [<a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/" rel="nofollow">实现 Trie (前缀树)</a>](#实现-trie-前缀树)
      * [主元素](#主元素)
   * [字符串处理](#字符串处理)
      * [<a href="https://leetcode-cn.com/problems/excel-sheet-column-title/" rel="nofollow">Excel表列名称</a>](#excel表列名称)
      * [<a href="https://leetcode-cn.com/problems/excel-sheet-column-number/" rel="nofollow">Excel表列序号</a>](#excel表列序号)
      * [翻转游戏](#翻转游戏)
      * [翻转字符串中的单词](#翻转字符串中的单词)
      * [最长公共前缀](#最长公共前缀)
      * [<a href="https://leetcode-cn.com/problems/palindrome-number/" rel="nofollow">回文数</a>](#回文数)
   * [矩阵](#矩阵)
      * [螺旋矩阵](#螺旋矩阵)
      * [判断数独是否合法](#判断数独是否合法)
      * [<a href="https://leetcode-cn.com/problems/rotate-image/" rel="nofollow">旋转图像</a>](#旋转图像)
   * [二进制 / 位运算](#二进制--位运算)
      * [落单的数](#落单的数)
      * [<a href="https://leetcode-cn.com/problems/gray-code/" rel="nofollow">格雷编码</a>](#格雷编码)
   * [其他](#其他)
      * [<a href="https://leetcode-cn.com/problems/reverse-integer/" rel="nofollow">整数反转</a>](#整数反转)
      * [<a href="https://leetcode-cn.com/problems/string-to-integer-atoi/" rel="nofollow">字符串转换整数 (atoi)</a>](#字符串转换整数-atoi)
      * [<a href="https://leetcode-cn.com/problems/sliding-window-maximum/" rel="nofollow">滑动窗口最大值</a>](#滑动窗口最大值)
      * [<a href="https://leetcode-cn.com/problems/lru-cache/" rel="nofollow">LRU缓存</a>](#lru缓存)
      * [<a href="https://leetcode-cn.com/problems/lfu-cache/" rel="nofollow">LFU缓存</a>](#lfu缓存)

# 排序

[这或许是东半球分析十大排序算法最好的一篇文章](https://www.cxyxiaowu.com/725.html)

## 比较排序
### 冒泡排序
重复地走访过要排序的数列，每次比较相邻两个元素，如果它们的顺序错误就把它们交换过来，越大的元素会经由交换慢慢“浮”到数列的尾端。
``` java
public void bubbleSort(int[] arr) {
    int temp = 0;
    boolean swap;
    for (int i = arr.length - 1; i > 0; i--) { // 每次需要排序的长度
        // 增加一个swap的标志，当前一轮没有进行交换时，说明数组已经有序
        swap = false;
        for (int j = 0; j < i; j++) { // 从第一个元素到第i个元素
            if (arr[j] > arr[j + 1]) {
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
                swap = true;
            }
        }
        if (!swap){
            break;
        }
    }
}
```

### 归并排序
分解待排序的数组成两个各具 n/2 个元素的子数组，递归调用归并排序两个子数组，合并两个已排序的子数组成一个已排序的数组。
```java
private int[] temp;//声明辅助数组

public void mergeSort(int[] nums) {
    int[] temp = new int[arr.length];
    mergeSort(nums, 0, arr.length - 1);
}

private void mergeSort(int[] nums, int l, int r) {
    if (l >= r)
    		return;
    int m = l + (r - l) / 2;
    mergeSort(nums, l, m);
    mergeSort(nums, m + 1, r);
    merge(nums, l, m, r);
}

private void merge(int[] nums, int l, int m, int r) {
    int i = l, j = m + 1, k = l;
    while (i <= m || j <= r) {
        if (i > m) {
            temp[k] = nums[j++];
        } else if (j > r) {
            temp[k] = nums[i++];
        } else if (nums[i] <= nums[j]) {
            temp[k] = nums[i++];
        } else {
            temp[k] = nums[j++];
        }
        k++;
    }
    // 把temp数据复制回原数组
    for (i = l; i <= r; i++)
        nums[i] = temp[i];
}
```

### 快速排序
在待排序的数组选取一个元素作为基准，将待排序的元素进行分区，比基准元素大的元素放在一边，比其小的放另一边，递归调用快速排序对两边的元素排序。选取基准元素并分区的过程采用双指针左右交换。
```java
public void quickSort(int[] arr){
    quickSort(arr, 0, arr.length-1);
}

private void quickSort(int[] arr, int low, int high){
    if (low >= high)
        return;
    int pivot = partition(arr, low, high);   //将数组分为两部分
    quickSort(arr, low, pivot - 1);          //递归排序左子数组
    quickSort(arr, pivot + 1, high);         //递归排序右子数组
}

//切分，小的在左边，大的在右边
private int partition(int[] nums, int l, int r) {
    // 选择一个随机数作为基准
    swap(nums, l, (int)(Math.random()*(r-l+1))+l);

    int i = l + 1, j = r;
    while (true) {
        while (i <= r && nums[i] < nums[l])
            i++;
        while (j > l && nums[j] > nums[l])
            j--;
        if (i > j)
            break;
        swap(nums, i, j);
        i++;
        j--;
    }
    swap(nums, l, j);
    return j;
}
```

## 线性排序
### 计数排序
根据待排序的数组中最大和最小的元素，统计数组中每个值为i的元素出现的次数，存入数组count的第i项，然后反向填充目标数组。适合元素范围取值比较小的情况。
```java
public void countSort(int[] nums) {
    int max = nums[0], min = nums[0];
    for (int num : nums) {
        max = Math.max(num, max);
      	min = Math.min(num, min);
    }

    int[] count = new int[max - min + 1]; // 计数数组

    for (int num : nums) {
      	count[num - min]++; // 每出现一个值，计数数组对应元素的值+1
    }

    int idx = 0;
    for (int num = min; num <= max; num++) {
      	int cnt = count[num - min];
      	while (cnt-- > 0) {
            nums[idx++] = num;
      	}
    }
}
```
### 桶排序
找出待排序数组中的最大值max、最小值min，数组ArrayList作为桶，桶里放的元素用ArrayList存储。计算每个元素 arr[i] 放的桶，每个桶各自排序，遍历桶数组，把排序好的元素放进输出数组。
```java
public static void bucketSort(int[] arr){
    int max = Integer.MIN_VALUE;
    int min = Integer.MAX_VALUE;
    for(int i = 0; i < arr.length; i++){
        max = Math.max(max, arr[i]);
        min = Math.min(min, arr[i]);
    }
    // 桶数
    int bucketNum = (max - min) / arr.length + 1;
    ArrayList<ArrayList<Integer>> bucketArr = new ArrayList<>(bucketNum);
    for(int i = 0; i < bucketNum; i++){
        bucketArr.add(new ArrayList<Integer>());
    }
    // 将每个元素放入桶
    for(int i = 0; i < arr.length; i++){
        int num = (arr[i] - min) / (arr.length);
        bucketArr.get(num).add(arr[i]);
    }
    // 对每个桶进行排序
    for(int i = 0; i < bucketArr.size(); i++){
        Collections.sort(bucketArr.get(i));
        for (int j = 0; j < bucketArr.get(i).size(); j++) {
            arr[j] = bucketArr.get(i).get(j);
        }
    }
}
```

# 数组 / 双指针

## [加一](https://leetcode-cn.com/problems/plus-one/)

> 给定一个非负数，表示一个数字数组，在该数的基础上+1，返回一个新的数组。该数字按照数位高低进行排列，最高位的数在列表的最前面。

```java
public int[] plusOne(int[] digits) {
  for (int i = digits.length - 1; i >= 0; i--) {
      //小于 9 的话，直接加 1，结束循环
      if (digits[i] < 9) {
          digits[i] += 1;
          break;
      } 
      //否则的话置为 0
      digits[i] = 0; 
  }
  //最高位如果置为 0 了，说明最高位产生了进位
  if (digits[0] == 0) {
      int[] ans = new int[digits.length + 1];
      ans[0] = 1; 
      digits = ans;
  }
  return digits;
}
```

## [多数元素](https://leetcode-cn.com/problems/majority-element/)

```java
class Solution {
    public int majorityElement(int[] nums) {
        //多数投票算法
        int cnt = 0,majority = nums[0];
        for (int num : nums) {
            if (cnt == 0) {
                majority = num;
            }
            cnt = (majority == num) ? cnt + 1 : cnt -1;
        }
        return majority;
    }
}
```

## [删除排序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

> 在**原数组**中“删除”重复出现的数字，使得每个元素只出现一次，并且返回“新”数组的长度。

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        //双指针
        int i = 0;
        for (int j = 1; j < nums.length; j++) {
            if (nums[i] != nums[j]) {
                i++;
                nums[i] = nums[j];
            }
        }
        return i+1;
    }
}
```

## [缺失的第一个正数](https://leetcode-cn.com/problems/first-missing-positive/)

>   给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。

```c++
//遍历一次数组把大于等于1的和小于数组大小的值放到原数组对应位置，然后再遍历一次数组查当前下标是否和值对应，如果不对应那这个下标就是答案，否则遍历完都没出现那么答案就是数组长度加1

class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        for (int i = 0; i < nums.size(); i++) {
            while (nums[i] > 0 && nums[i] <= nums.size() && nums[i] != nums[nums[i]-1]) {
                swap(nums[i], nums[nums[i]-1]);
            }
        }
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] != i + 1) {
                return i+1;
            }
        }
        return nums.size() + 1;
    }
};
```

```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        for (int i = 0; i < nums.length; i++) {
            while (nums[i] > 0 && nums[i] <= nums.length && nums[i] != nums[nums[i]-1]) {
                swap(nums, i, nums[i]-1);
            }
        }
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] != i+1) {
                return i+1;
            }
        }
        return nums.length+1;
    }

    private void swap (int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

## [寻找重复数](https://leetcode-cn.com/problems/find-the-duplicate-number/)

>   给定一个包含 *n* + 1 个整数的数组 *nums*，其数字都在 1 到 *n* 之间。
>
>   假设只有一个重复的整数，找出这个重复的数。

```java
class Solution {
    public int findDuplicate(int[] nums) {
        // Set<Integer> set = new HashSet<Integer>();
        // for (int num : nums) {
        //     if (set.contains(num)) { // set去重
        //         return num;
        //     }
        //     set.add(num);
        // }
        // return -1;

        // 快慢指针，链表有环
        // 可以使用数组配合下标，抽象成链表问题
        // 举个例子：nums = [2,5,9,6,9,3,8,9,7,1]，构造成链表就是：2->[9]-           // >1->5->3->6->8->7->[9]，也就是在[9]处循环
        int slow = 0;
        int fast = 0;
        slow = nums[slow];
        fast = nums[nums[fast]];
        while (slow != fast) {
            slow = nums[slow];
            fast = nums[nums[fast]];
        }
        slow = 0;
        while (slow != fast) {
            slow = nums[slow];
            fast = nums[fast];
        }
        return slow;
    }
}
```

## [两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)

>   输入: nums1 = [1,2,2,1], nums2 = [2,2]
>
>   输出: [2]

```java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        HashSet<Integer> set = new HashSet<>();// 去重
        for(int num : nums1)
            set.add(num);

        ArrayList<Integer> list = new ArrayList<>();
        for(int num : nums2){
            if(set.contains(num)) {
                list.add(num);
                set.remove(num);
            }
        }

        int[] res = new int[list.size()];
        for(int i = 0; i < list.size(); i ++)
            res[i] = list.get(i);
      
        return res;
    }
}
```

>   输入: nums1 = [1,2,2,1], nums2 = [2,2]
>
>   输出: [2,2]

```java
class Solution {
    public int[] intersect(int[] nums1, int[] nums2) {
        HashMap<Integer, Integer> map = new HashMap<>();
        // 统计num频次
        for(int num : nums1) {
            if(!map.containsKey(num))
                map.put(num, 1);
            else
                map.put(num, map.get(num) + 1);
        }

        ArrayList<Integer> list = new ArrayList<>();
        for(int num : nums2) {
            if(map.containsKey(num)) {
                list.add(num);
                map.put(num, map.get(num) - 1);
                if(map.get(num) == 0)
                    map.remove(num);
            }
        }

        int[] res = new int[list.size()];
        for(int i = 0 ; i < list.size() ; i++)
            res[i] = list.get(i);

        return res;
    }
}
```

## [两数之和](https://leetcode-cn.com/problems/two-sum/)

>   给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那 **两个** 整数

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        // 暴力穷举，O(n2)
        // 空间换时间,map 查找O(1)
        Map<Integer,Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            int ret = target - nums[i];
            if (map.containsKey(ret)) {
                return new int[] {map.get(ret),i};
            }
            map.put(nums[i],i);
        }
        return null;
    }
}
```

## [两数之和 II](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)

>   给定一个已按照**升序排列** 的有序数组，找到两个数使得它们相加之和等于目标数。

```java
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        //双指针
        int l = 0 ,r = numbers.length - 1;
        while (l < r) {
            int sum = numbers[l] + numbers[r];
            if (sum == target) {
                return new int[] {l+1,r+1};
            } else if (sum < target) {
                l++;
            } else {
                r--;
            }
        }
        return null;
    }
}
```

>   设计一个类，拥有两个 API

```java
class TwoSum {
    Set<Integer> sum = new HashSet<>();
    List<Integer> nums = new ArrayList<>();
    // 添加一个数 number
    public void add(int number) {
        // 记录所有可能组成的和
        for (int n : nums)
            sum.add(n + number);
        nums.add(number);
    }
    // 寻找是否存在两个数的和为 value
    public boolean find(int value) {
        return sum.contains(value);
    }
}
```

## [两数之和BST](https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/)

>   给定一个二叉搜索树和一个目标结果，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。

```java
class Solution {
    public boolean findTarget(TreeNode root, int k) {
        List<Integer> res = new ArrayList<>();
        if (root == null)
            return false;
        inOrder(root, res);
        int l = 0, r = res.size() - 1;
        while (l < r) {
            int sum = res.get(l) + res.get(r);
            if (sum == k) {
                return true;
            } else if (sum < k) {
                l++;
            } else {
                r--;
            }
        }
        return false;
    }

    private void inOrder(TreeNode node, List<Integer> list) {
        if (node == null) 
            return;
        inOrder(node.left, list);
        list.add(node.val);
        inOrder(node.right, list);
    }
}
```

## [三数之和](https://leetcode-cn.com/problems/3sum/)

>   判断 `nums` 中是否存在三个元素 *a，b，c ，*使得 *a + b + c =* 0 

-   三数和：一层循环，循环里一个双指针，先定位第一个元素，然后判断后两个元素。判重是根据 当前元素不等于上一个元素。
-   三数接近和：同样一个道理，只不过这个不用判重，只要算出最小差值就行了。
-   四数和：双层f循环+双指针。 

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        Arrays.sort(nums); // 排序
        for (int i = 0; i < nums.length - 2; i++) {
            // 如果当前数字大于0，则三数之和一定大于0，所以结束循环
            if (nums[i] > 0) 
                break; 
            if (i > 0 && nums[i] == nums[i - 1]) 
                continue; // 去重
            int l = i + 1, r = nums.length - 1;
            while (l < r) {
                int sum = nums[i] + nums[l] + nums[r];
                if (sum == 0) {
                    res.add(Arrays.asList(nums[i],nums[l],nums[r]));
                    while (l < r && nums[l] == nums[l + 1]) l++; // 去重
                    while (l < r && nums[r] == nums[r - 1]) r--; // 去重
                    l++;
                    r--;
                } else if (sum < 0) {
                    l++;
                } else if (sum > 0) { 
                    r--;
                }
            }
        }
        return res;
    }
}
```

## [最接近的三数之和](https://leetcode-cn.com/problems/3sum-closest/)

>   找出 `nums` 中的三个整数，使得它们的和与 `target` 最接近

```java
class Solution {
    public int threeSumClosest(int[] nums, int target) {
        Arrays.sort(nums);
        int res = nums[0] + nums[1] + nums[2];
        for (int i = 0; i < nums.length - 2; i++) {
            int l = i + 1, r = nums.length - 1;
            while (l < r) {
                int sum = nums[i] + nums[l] + nums[r];
                if (Math.abs(sum - target) < Math.abs(res - target)) {
                    res = sum;
                }
                if (sum > target) {
                    r--;
                } else if (sum < target) {
                    l++;
                } else {
                    return target;
                }
            }
        }
        return res;
    }
}
```

## [四数之和](https://leetcode-cn.com/problems/4sum/)

>   判断 `nums` 中是否存在四个元素 a，b，c 和 *d* ，使得 *a* + *b* + *c* + *d* 的值与 `target` 相等

```java
class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        List<List<Integer>> res = new ArrayList<>();
        Arrays.sort(nums); // 排序
        for (int i = 0; i < nums.length - 3; i++) {
            if (nums[i] > target / 4) // 剪枝
                break;
            if (i > 0 && nums[i] == nums[i-1]) 
                continue; // 去重
            for (int j = i + 1; j < nums.length - 2; j++) {
                if (nums[j] > (target - nums[i]) / 3) // 剪枝
                    break;
                if (j > i +1 && nums[j] == nums[j-1]) 
                    continue; // 去重
                int l = j + 1, r = nums.length - 1;
                while (l < r) {
                    int sum = nums[i] + nums[j] + nums[l] + nums[r];
                    if (sum == target) {
                        res.add(Arrays.asList(nums[i],nums[j],nums[l],nums[r]));
                        while (l < r && nums[l] == nums[l+1]) l++; // 去重
                        while (l < r && nums[r] == nums[r-1]) r--; // 去重
                        l++;
                        r--;
                    } else if (sum < target) {
                        l++;
                    } else if (sum > target) { 
                        r--;
                    }
                }
            }
        }
        return res;
    }
}
```



## [合并排序的数组](https://leetcode-cn.com/problems/sorted-merge-lcci/)

> 合并两个排序的整数数组A和B变成一个新的数组。可以假设A具有足够的空间去添加B中的元素。

```java
class Solution {
    public void merge(int[] A, int m, int[] B, int n) {
        //双指针
        int i = m - 1;
        int j = n - 1;
        int k = m + n - 1;
        while (i >= 0 && j >= 0) {
            if (A[i] > B[j]) {
                A[k--] = A[i--];
            } else {
                A[k--] = B[j--];
            }
        }
        // 如果是A中元素先遍历完，就把B中元素复制过来
        // 如果是B中元素先遍历完，就已经完成操作
        while (j >= 0) {
            A[k--] = B[j--];
        }
    }
}
```

# 二分查找

## [x 的平方根](https://leetcode-cn.com/problems/sqrtx/)

>   由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。

```java
class Solution {
    public int mySqrt(int x) {
        if (x <= 1)
            return x;
        int l = 1, h = x;
        while (l <= h) {
            int m = l + (h - l) / 2;
            int sqrt = x / m;
            if (m == sqrt) {
                return m;
            } else if (m > sqrt) {
                h = m - 1;
            } else {
                l = m + 1;
            }
        }
        return h;
    }
}
```

## [Pow(x, n)](https://leetcode-cn.com/problems/powx-n/)

快速幂

```java
class Solution {
    public double myPow(double x, int n) {
        double res = 1.0;
        // O(logn)
        for(int i = n; i != 0; i /= 2){
            if(i % 2 != 0){
                res *= x;
            }
            x *= x;
        }
        return  n < 0 ? 1 / res : res;
    }
}
```

## [平方数之和](https://leetcode-cn.com/problems/sum-of-square-numbers/)

>   给定一个非负整数 `c` ，你要判断是否存在两个整数 `a` 和 `b`，使得 a2 + b2 = c。

```java
class Solution {
    public boolean judgeSquareSum(int c) {
        int a = 0, b = (int) Math.sqrt(c);
        while (a <= b) {
            int sum = a * a + b * b;
            if (sum == c) {
                return true;
            } else if (sum < c) {
                a++;
            } else {
                b--;
            }
        }
        return false;
    }
}
```

## [在排序数组中查找元素](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

>   给定一个按照升序排列的整数数组 `nums`，和一个目标值 `target`。找出给定目标值在数组中的开始位置和结束位置。

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int first = binarySearch(nums, target);
        int last = binarySearch(nums,target + 1) - 1;
        if (first == nums.length || nums[first] != target) {
            return new int[]{-1,-1};
        } else {
            return new int[]{first,last};
        }
    }

    //不存在的话 返回要插入的位置
    private int binarySearch (int[] nums, int target) {
        int l = 0, h = nums.length;
        while (l < h) {
            int m = l + (h - l) / 2;
            if (nums[m] >= target) {
                h = m;
            } else {
                l = m + 1;
            }
        }
        return l;
    }
}
```

## [0～n-1中缺失的数字](https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/)

>   输入: [0,1,2,3,4,5,6,7,9]
>
>   输出: 8

```java
class Solution {
    public int missingNumber(int[] nums) {

        // for (int i = 0; i < nums.length; i ++) {
        //     if (nums[i] != i)
        //         return i;
        // }
        // return nums.length;

        // 二分
        int l = 0, h = nums.length;
        while (l < h) {
            int m = l + (h - l) / 2;
            if (nums[m] == m) {
                l = m + 1;
            } else {
                h = m;
            }
        }
        return l;
    }
}
```

## [旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)

>   输入: [3,4,5,1,2]
>
>   输出: 1

```java
class Solution {
    public int findMin(int[] nums) {
        int l = 0, h = nums.length - 1;
        while (l < h) {
            int m = l + (h - l) / 2;
            if (nums[m] <= nums[h]) {
                h = m;
            } else {
                l = m + 1;
            }
        }
        return nums[l];
    }
}
```

## [旋转排序数组中的最小值 II](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/)

>   数组中可能存在重复的元素

```java
class Solution {
    public int findMin(int[] nums) {
        // for (int i = 0; i < nums.length - 1; i++) {
        //     if (nums[i] > nums[i + 1])
        //         return nums[i + 1];
        // }
        // return nums[0];

        //二分 O(logn)
        int l = 0, h = nums.length - 1;
        while (l < h) {
            int m = l + (h - l) / 2;
            if (nums[m] > nums[h]) {
                l = m + 1;
            } else if (nums[m] < nums[h]) {
                h = m;
            } else {//无法判断m是位于前半部分还是后半部分，缩小查找范围
                h--;
            }
        }
        return nums[l];
    }
}
```

# 链表

```java
public class ListNode {
     int val;
     ListNode next;
     ListNode(int x) {
         val = x;
         next = null;
    }
}
```

## [删除节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/)
```java
public void deleteNode(ListNode node) {
    if (node.next == null){
        node = null;
        return;
    }
    //没有head,无法定位到preNode
    node.val = node.next.val;
    node.next = node.next.next;
}
```

## [移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)

```java
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        ListNode dummyHead = new ListNode(-1);
        dummyHead.next = head;

        ListNode cur = dummyHead;
        while(cur.next != null){
            if(cur.next.val == val) {
                cur.next = cur.next.next;
            } else {
                cur = cur.next;
            }
        }

        return dummyHead.next;
    }
}
```

## [删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)

```java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {

        ListNode cur = head;
        while (cur != null && cur.next != null) {
            if (cur.val == cur.next.val) {
                cur.next = cur.next.next;
            } else {
                cur = cur.next;
            }
        }
        return head;
    }
}
```

## [删除倒数第N个节点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        // 构造虚拟头结点，方便删除head头结点
        ListNode dummyHead = new ListNode(-1);
        dummyHead.next = head;
        // 双指针
        ListNode p1 = dummyHead, p2 = dummyHead;
        
        for (int i = 1; i <= n+1; i++) {
            p1 = p1.next;
        }

        while (p1 != null) {
            p1 = p1.next;
            p2 = p2.next;
        }

        p2.next = p2.next.next;
        return dummyHead.next;
    }
}
```

## [中间结点](https://leetcode-cn.com/problems/middle-of-the-linked-list/)

>   给定一个带有头结点 `head` 的非空单链表，返回链表的中间结点。
>
>   如果有两个中间结点，则返回第二个中间结点。

```java
class Solution {
    public ListNode middleNode(ListNode head) {
        //快指针到最后一个结点，慢指针正好在中间
        ListNode fast = head, slow = head;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }
}
```

## [环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

>   给定一个链表，判断链表中是否有环。

```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        //环形链表 至少有两个节点
        if (head == null || head.next == null)
            return false;
        ListNode slow = head, fast = head;
        do {
            if (fast == null || fast.next == null) {
                return false;
            }
            slow = slow.next;
            fast = fast.next.next;
        } while (slow != fast);
        
        return true;
    }
}
```
>   给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 `null`。

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        //环型链表 至少有两个节点
        if (head == null || head.next == null)
            return null;
        ListNode slow = head, fast = head;
        do {
            if (fast == null || fast.next == null) {
                return null;
            }
            slow = slow.next;
            fast = fast.next.next;
        } while (slow != fast);

        fast = head;
        while (slow != fast) {
            slow = slow.next;
            fast = fast.next;
        }
        
        return slow;
    }
}
```

## [反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        // 迭代
        // ListNode pre = null;
        // ListNode cur = head;
        // while (cur != null) {
        //     ListNode next = cur.next;
        //     cur.next = pre;
        //     pre = cur;
        //     cur = next;
        // }
        // return pre;

        // 递归
        if (head.next == null)
            return head;
        ListNode newHead = reverseList(head.next);
        head.next.next = head;
        head.next = null;
        return newHead;
    }
}
```

## [反转区间链表](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

>   反转从位置 *m* 到 *n* 的链表。请使用一趟扫描完成反转。
>
>   **说明:**
>   1 ≤ *m* ≤ *n* ≤ 链表长度。

```java
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        ListNode dummyHead = new ListNode(0, head);
        ListNode pre = dummyHead;
        for (int i = 0; i < left - 1; i++) {
            pre = pre.next;
        }
        head = pre.next;
        for (int i = left; i < right; i++) {
            ListNode next = head.next;
            head.next = next.next;
            next.next = pre.next;
            pre.next = next;
        }
        return dummyHead.next;
    }
}
```

## [K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

>   给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。
>
>   k 是一个正整数，它的值小于或等于链表的长度。
>
>   如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

```java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode dummyHead = new ListNode(0, head);
        ListNode pre = dummyHead, next;
        int len = 0;
        while (head != null) {
            head = head.next;
            len++;
        }
        head = dummyHead.next;
        for (int i = 0; i < len / k; i++) {
            for (int j = 0; j < k - 1; j++) {
                next = head.next;
                head.next = next.next;
                next.next = pre.next;
                pre.next = next;
            }
            pre = head;
            head = head.next;
        }
        return dummyHead.next;
    }
}
```

## [合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

>   将两个升序链表合并为一个新的升序链表

```java
class Solution {
    // //递归
    // public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    //     if (l1 == null) return l2;
    //     if (l2 == null) return l1;
    //     if (l1.val < l2.val) {
    //         l1.next = mergeTwoLists(l1.next,l2);
    //         return l1;
    //     } else {
    //         l2.next = mergeTwoLists(l1,l2.next);
    //         return l2;
    //     }
    // }

    //迭代
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if (l1 == null) return l2;
        if (l2 == null) return l1;
        ListNode dummyHead = new ListNode(-1);
        ListNode cur = dummyHead;
        while (l1 != null && l2 != null) {
            if (l1.val < l2.val) {
                cur.next = l1;
                l1 = l1.next;
            } else {
                cur.next = l2;
                l2 = l2.next;
            }
            cur = cur.next;
        }

        cur.next = l1 != null ? l1 : l2;

        return dummyHead.next;
    }
}
```

## [合并K个排序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

>   合并 *k* 个排序链表，返回合并后的排序链表

```java
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        // 暴力,排序所有链表的值，再创建新的链表
        // List<Integer> list = new ArrayList<>();
        // for (ListNode l : lists) {
        //     while (l != null) {
        //         list.add(l.val);
        //         l = l.next;
        //     }
        // }
        // Collections.sort(list);
        // ListNode dummyHead = new ListNode(0);
        // ListNode cur = dummyHead;
        // for (int n : list) {
        //     ListNode node = new ListNode(n);
        //     cur.next = node;
        //     cur = cur.next;
        // }
        // cur.next = null;
        // return dummyHead.next;

        // 最小堆
        // 把链表的头结点都放入堆中，然后出队，挂上链表
        // 然后让出队的那个节点的下一个入队，再出队，直到优先队列为空

        if (lists == null || lists.length == 0) 
            return null;
        
        PriorityQueue<ListNode> pq = new PriorityQueue<>(
                                (l1, l2) -> l1.val - l2.val);
        for (ListNode l : lists) {
            if (l != null) {
                pq.add(l);
            }
        }

        ListNode dummyHead = new ListNode(0);
        ListNode cur = dummyHead;
        while (!pq.isEmpty()) {
            ListNode node = pq.poll();
            cur.next = node;
            cur = cur.next;
            if (node.next != null) {
                pq.add(node.next);
            }
        }
        return dummyHead.next;
    }
}
```

## [排序链表](https://leetcode-cn.com/problems/sort-list/)

```java
// 归并排序
public ListNode sortList(ListNode head) {
    if (head == null || head.next == null) {
        return head;
    }

    ListNode mid = findMiddle(head);

    ListNode right = sortList(mid.next);
    mid.next = null;
    ListNode left = sortList(head);

    return mergeTwoLists(left, right);
}

// 快速排序
public ListNode sortList(ListNode head) {
    quickSort(head, null);
    return head;
}

private void quickSort(ListNode start, ListNode end) {
    if (start == end) {
        return;
    }
    
    ListNode pt = partition(start, end);
    quickSort(start, pt);
    quickSort(pt.next, end);
}

private ListNode partition(ListNode start, ListNode end) {
    int pivotKey = start.val;
    ListNode p1 = start, p2 = start.next;
    while (p2 != end) {
        if (p2.val < pivotKey) {
            p1 = p1.next;
            swapValue(p1, p2);
        }
        p2 = p2.next;
    }
    
    swapValue(start, p1);
    return p1;
}

private void swapValue(ListNode node1, ListNode node2) {
    int tmp = node1.val;
    node1.val = node2.val;
    node2.val = tmp;
}
```

## [相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)
```java
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode l1 = headA,l2 = headB;
        //a+c+b = b+c+a
        while (l1 != l2) {
            l1 = l1 == null ? headB : l1.next;
            l2 = l2 == null ? headA : l2.next;
        }
        return l1;
}
```

## [回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)

>   1->2->2->1

```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        if (head == null || head.next == null)
            return true;
        //双指针遍历，分割链表    
        ListNode slow = head, fast = head.next;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        fast = slow.next;
        slow.next = null;

        //反转链表
        ListNode prev = null;
        while (fast != null) {
            ListNode next = fast.next;
            fast.next = prev;
            prev = fast;
            fast = next;
        }

        //比对
        while (prev != null) {
            if (head.val != prev.val) {
                return false;
            }
            head = head.next;
            prev = prev.next;
        }

        return true;

    }
}
```

## [奇偶链表](https://leetcode-cn.com/problems/odd-even-linked-list/)

>   给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。
>
>   应当保持奇数节点和偶数节点的相对顺序。

```java
class Solution {
    public ListNode oddEvenList(ListNode head) {
        if (head == null)
            return null;
        // 保存一下偶数节点的头节点
        ListNode odd = head, even = head.next, evenHead = even;
        while (even != null && even.next != null) {
            odd.next = odd.next.next;
            odd = odd.next;
            even.next = even.next.next;
            even = even.next;
        }
        odd.next = evenHead;
        
        return head;
    }
}
```

## [从尾到头打印链表](https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/)

```java
class Solution {
    public int[] reversePrint(ListNode head) {
        Stack<Integer> stack = new Stack<>();
        while (head != null) {
            stack.push (head.val);
            head = head.next;
        }
        int[] res = new int[stack.size()];
        int i = 0;
        while (!stack.isEmpty()) {
            res[i++] = stack.pop();
        }
        return res;
    }
}
```

## [两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

```java
class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode dummyHead = new ListNode(-1);
        dummyHead.next = head;
        ListNode prev = dummyHead;

        while (prev.next != null && prev.next.next != null) {
            ListNode cur = prev.next;
            ListNode next = cur.next;

            prev.next = next;
            cur.next = next.next;
            next.next = cur;
            prev = cur;
        }

        return dummyHead.next;
    }
}
```

## [复制带随机指针的链表](https://leetcode-cn.com/problems/copy-list-with-random-pointer/)

```java
class Solution {
    public Node copyRandomList(Node head) {
        if (head == null)
            return null;
        // 1.在每个节点的后面插入复制的节点
        Node cur = head;
        while (cur != null) {
            Node clone = new Node(cur.val);
            clone.next = cur.next;
            cur.next = clone;
            cur = clone.next;
        } 
        // 2.建立 random 链接
        cur = head;
        while (cur != null) {
            Node clone = cur.next;
            if (cur.random != null)
                clone.random = cur.random.next;
            cur = clone.next;
        }
        // 3.拆分
        cur = head;
        Node cloneHead = head.next;
        while (cur.next != null) {
            Node next = cur.next;
            cur.next = next.next;
            cur = next;
        }
        return cloneHead;
    }
}
```

## [两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

>   两个 **非空** 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 **逆序** 的方式存储

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummyHead = new ListNode(-1);
        ListNode cur = dummyHead;
        int carry = 0;//进位
        while (l1 != null || l2 != null || carry != 0) {
            int val1 = l1 != null ? l1.val : 0;
            int val2 = l2 != null ? l2.val : 0;
            int sum = val1 + val2 + carry;
            carry = sum / 10;

            ListNode node = new ListNode(sum % 10);
            cur.next = node;
            cur = node;
            
            if (l1 != null) l1 = l1.next;
            if (l2 != null) l2 = l2.next;
        }
        return dummyHead.next;
    }
}
```

## [两数相加 II](https://leetcode-cn.com/problems/add-two-numbers-ii/)

>   数字最高位位于链表开始位置，按照 **顺序** 的方式存储

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        Stack<Integer> stack1 = buildStack(l1);
        Stack<Integer> stack2 = buildStack(l2);
        ListNode dummyHead = new ListNode(-1);

        int carry = 0;
        while (!stack1.isEmpty() || !stack2.isEmpty() || carry != 0) {
            int a = stack1.isEmpty() ? 0 : stack1.pop();
            int b = stack2.isEmpty() ? 0 : stack2.pop();
            int sum = a + b + carry;
            carry = sum / 10;
            // 插入节点
            ListNode node = new ListNode(sum % 10);
            node.next = dummyHead.next;
            dummyHead.next = node;
        }

        return dummyHead.next;
    }

    private Stack<Integer> buildStack(ListNode l) {
        Stack<Integer> stack = new Stack<>();
        while (l != null) {
            stack.push(l.val);
            l = l.next;
        }
        return stack;
    }
}
```

# 栈 / 队列

## [最小栈](https://leetcode-cn.com/problems/min-stack/)
> 实现一个栈, 额外支持一个操作：min() 返回栈中元素的最小值
```java
class MinStack {
    private Stack<Integer> stack;
    private Stack<Integer> minStack;
    
    public MinStack() {
        stack = new Stack<>();
        minStack = new Stack<>();
    }
    
    public void push(int x) {
        stack.push(x);
        if (minStack.isEmpty() || x <= minStack.peek()) {
            minStack.push(x);
        } else {
            minStack.push(minStack.peek());
        }
    }
    
    public void pop() {
        stack.pop();
        minStack.pop();
    }
    
    public int top() {
        return stack.peek();
    }
    
    public int getMin() {
        return minStack.peek();
    }
}
```

## [验证栈序列](https://leetcode-cn.com/problems/validate-stack-sequences/)

```java
class Solution {
    public boolean validateStackSequences(int[] pushed, int[] popped) {
        //模拟入栈出栈
        Stack<Integer> stack = new Stack<>();
        int j = 0;
        for (int i : pushed) {
            stack.push(i);
            while (!stack.isEmpty() &&
                   j < popped.length &&
                   stack.peek() == popped[j]) {
                stack.pop();
                j++;
            }
        }
        return stack.isEmpty();
    }
}
```

## [有效括号](https://leetcode-cn.com/problems/valid-parentheses/)

> 给定一个字符串所表示的括号序列，包含以下字符： '(', ')', '{', '}', '[' and ']'， 判定是否是有效的括号序列。括号必须依照 "()" 顺序表示， "()[]{}" 是有效的括号，但 "([)]" 则是无效的括号。
```java
class Solution {
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();
        char[] arr = s.toCharArray();
        for (char c : arr) {
            if (c == '(' || c == '{' || c == '[') {
                stack.push(c);
            } else {
                if (stack.isEmpty()) 
                    return false;
                char ch = stack.pop();
                boolean b1 = c == ')' && ch != '(';
                boolean b2 = c == '}' && ch != '{';
                boolean b3 = c == ']' && ch != '[';
                if (b1 || b2 || b3)
                    return false;
            }
        }
        return stack.isEmpty();
    }
}
```

## [括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

>   数字 *n* 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。
>
>   输入：n = 3
>   输出：[
>          "((()))",
>          "(()())",
>          "(())()",
>          "()(())",
>          "()()()"
>        ]

```java
class Solution {
    private List<String> res = new ArrayList<String>();

    public List<String> generateParenthesis(int n) {
        dfs(n, n, "");
        return res;
    }

    private void dfs(int l, int r, String s) {
        // 左右括号都不剩余了，递归终止
        if (l == 0 && r == 0) {
            res.add(s);
            return;
        }
        // 如果左括号还剩余的话，可以拼接左括号
        if (l > 0) {
            dfs(l - 1, r, s + '(');
        }
        // 如果右括号剩余多于左括号剩余的话，可以拼接右括号
        if (r > l) {
            dfs(l, r - 1, s + ')');
        }
    }
}
```

## [用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)

```java
class MyQueue {
    private Stack<Integer> s1;
    private Stack<Integer> s2;

    public MyQueue() {
        s1 = new Stack<>();
        s2 = new Stack<>();
    }
    
    public void push(int x) {
        s1.push(x);
    }
    
    public int pop() {
        s1Tos2();
        return s2.pop();
    }
    
    public int peek() {
        s1Tos2();
        return s2.peek();
    }

    private void s1Tos2() {
        if (s2.isEmpty()) {
            while (!s1.isEmpty()) {
                s2.push(s1.pop());
            }
        }
    }
    
    public boolean empty() {
        return s1.isEmpty() && s2.isEmpty();
    }
}
```

## [用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)

```java
class MyStack {
    private Queue<Integer> queue;

    public MyStack() {
        queue = new LinkedList<>();
    }
    
    public void push(int x) {
        queue.add(x);
        int cnt = queue.size();
        while(cnt > 1) {
            queue.add(queue.poll());
            cnt--;
        }
    }
    
    public int pop() {
        return queue.poll();
    }
    
    public int top() {
        return queue.peek();
    }
    
    public boolean empty() {
        return queue.isEmpty();
    }
}
```

## 逆波兰表达式求值

> 在反向波兰表示法中计算算术表达式的值, ["2", "1", "+", "3", "*"] -> (2 + 1) * 3 -> 9
```java
public int evalRPN(String[] tokens) {
    Stack<Integer> s = new Stack<Integer>();
    String operators = "+-*/";
    for (String token : tokens) {
        if (!operators.contains(token)) {
            s.push(Integer.valueOf(token));
            continue;
        }

        int a = s.pop();
        int b = s.pop();
        if (token.equals("+")) {
            s.push(b + a);
        } else if(token.equals("-")) {
            s.push(b - a);
        } else if(token.equals("*")) {
            s.push(b * a);
        } else {
            s.push(b / a);
        }
    }
    return s.pop();
}
```

# 哈希表

[哈希表](https://leetcode-cn.com/tag/hash-table/)

# 堆 / 优先队列
## [数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)
```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        // 1.排序
        // Arrays.sort(nums);
        // return nums[nums.length - k];
        
        // 2.建立小顶堆（默认是小顶堆）
        // PriorityQueue<Integer> pq = new PriorityQueue<Integer>();
        // for (int num : nums) {
        //     pq.add(num);
        //     if (pq.size() > k) {
        //         pq.poll();
        //     }
        // }
        // return pq.peek();

        // 3.快速选择（快排，分治，双指针）
        k = nums.length - k;
        int l = 0, r = nums.length - 1;
        while (l < r) {
            int index = partition(nums, l, r);
            if (index == k) {
                break;
            } else if (index > k) {
                r = index - 1;
            } else {
                l = index + 1;
            }
        }
        return nums[k];
    }

    //切分，小的在左边，大的在右边
    private int partition(int[] nums, int l, int r) {
        // 选择一个随机数作为基准
        swap(nums, l, (int)(Math.random()*(r-l+1))+l);

        int i = l + 1, j = r;
        while (true) {
            while (i <= r && nums[i] < nums[l])
                i++;
            while (j > l && nums[j] > nums[l])
                j--;
            if (i > j)
                break;
            swap(nums, i, j);
            i++;
            j--;
        }
        swap(nums, l, j);
        return j;
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

## [最小的k个数](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/)

```java
class Solution {
    public int[] getLeastNumbers(int[] arr, int k) {
        //大顶堆-最小的K个数
        //小顶堆-最大的K个数
        PriorityQueue<Integer> pq = new PriorityQueue<>(
                                        (a, b) -> b - a);
        for (int n : arr) {
            pq.add(n);
            if (pq.size() > k) {
                pq.poll();
            }
        }

        int[] res = new int[k];
        for (int i = 0; i < k; i++) {
            res[i] = pq.poll();
        }
        return res;
    }
}
```

## [前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)

>   给定一个非空的整数数组，返回其中出现频率前k高的元素。

```java
class Solution {
    public List<Integer> topKFrequent(int[] nums, int k) {
        // 统计每个元素出现的次数
        Map<Integer, Integer> map = new HashMap<>();
        for (int num : nums) {
            if (map.containsKey(num)) {
                map.put(num, map.get(num) + 1);
            } else {
                map.put(num, 1);
            }
        }

        // 1.最小堆
        // PriorityQueue<Integer> pq = new PriorityQueue<>(
        //     new Comparator<Integer>() {
        //             @Override
        //             public int compare(Integer a, Integer b) {
        //                 return map.get(a) - map.get(b);
        //             }
        //         });
        
        // 遍历map，用最小堆保存频率最大的k个元素
        // PriorityQueue<Integer> pq = new PriorityQueue<>(
        //                             (a, b) -> map.get(a) - map.get(b));
        // for (int key : map.keySet()) {
        //     if (pq.size() < k) {
        //         pq.add(key);
        //     } else if (map.get(key) > map.get(pq.peek())) {
        //         pq.poll();
        //         pq.add(key);
        //     }
        // }
        // // 取出最小堆中的元素
        // List<Integer> res = new ArrayList<>();
        // while (!pq.isEmpty()) {
        //     res.add(pq.poll());
        // }
        // return res;

        // 2.桶排序
        //将频率作为数组下标
        List<Integer>[] list = new ArrayList[nums.length + 1];
        for (int key : map.keySet()) {
            int i = map.get(key);
            if (list[i] == null) {
                list[i] = new ArrayList<>();
            }
            list[i].add(key);
        }

        //逆序输出数组元素
        List<Integer> res = new ArrayList<>();
        for (int i = list.length - 1; i >= 0 && res.size() < k; i--) {
            if (list[i] == null) 
                continue;
            if (list[i].size() <= k - res.size()) {
                res.addAll(list[i]);
            } else {
                res.addAll(list[i].subList(0, k - res.size()));
            }
        }
        return res;
    }
}
```

# 二叉树

```java
class TreeNode {
    public TreeNode left, right;
    public int val;

    public TreeNode(int val) {
        this.val = val;
    }
}
```

## 顺序遍历

>   前序遍历: 根->左->右
>
>   中序遍历: 左->根->右  
>
>   后序遍历: 左->右->根

#### [前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

#### [中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

#### [后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

```java
// 前序遍历
// 递归，dfs
public List<Integer> preOrder(TreeNode root) {
     List<Integer> res = new ArrayList<>();
     dfs(root, res);
     return res;
}
private void dfs(TreeNode root, List<Integer> res) {
     if (root == null) 
         return;
     res.add(root.val);
     dfs(root.left, res);
     dfs(root.right, res);
}

// 迭代
public List<Integer> preOrder(TreeNode root) {
    List<Integer> res = new ArrayList<>();
    if (root == null)
       return res;
    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
    while (!stack.isEmpty()) {
       TreeNode cur = stack.pop();
       res.add(cur.val);
       //先右后左
       if (cur.right != null)
       		stack.push(cur.right);
       if (cur.left != null)
          stack.push(cur.left);
    }
    return res;
}

// 中序遍历
// 递归
public List<Integer> inOrder(TreeNode root) {
     List<Integer> res = new ArrayList<>();
     dfs(root, res);
     return res;
}
private void dfs(TreeNode root, List<Integer> res) {
     if (root == null) 
         return;
     dfs(root.left, res);
     res.add(root.val);
     dfs(root.right, res);
}

// 迭代
public List<Integer> inOrder(TreeNode root) {
    List<Integer> res = new ArrayList<>();
    if (root == null)
        return res;
    Stack<TreeNode> stack = new Stack<>();
    TreeNode cur = root;
    while (cur != null || !stack.isEmpty()) {
        // 不断往左子树方向走，每走一次就将当前节点保存到栈中
			  // 模拟递归的调用
        while (cur != null) {
            stack.push(cur);
            cur = cur.left;
        }
        // 左边走到头了，从栈中弹出节点并保存
			  // 然后转向右边节点，继续上面整个过程
        cur = stack.pop();
        res.add(cur.val);
        cur = cur.right;
    }
    return res;
}

// 后序遍历
// 递归
public List<Integer> postOrder(TreeNode root) {
     List<Integer> res = new ArrayList<>();
     dfs(root, res);
     return res;
}
private void dfs(TreeNode root, List<Integer> res) {
     if (root == null) 
         return;
     dfs(root.left, res);
     dfs(root.right, res);
     res.add(root.val);
}

//迭代
public List<Integer> postOrder(TreeNode root) {
    List<Integer> res = new ArrayList<>();
    if (root == null)
        return res;
    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
    while (!stack.isEmpty()) {
        TreeNode cur = stack.pop();
        //res.add(cur.val);
        res.add(0, cur.val);//逆序添加结点值
        //先左后右
        if (cur.left != null)
            stack.push(cur.left);
        if (cur.right != null)
            stack.push(cur.right);
    }
    // Collections.reverse(res);
    return res;
}
```

## [前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

```java
class Solution {
    // 缓存中序遍历数组每个值对应的索引
    private Map<Integer, Integer> map = new HashMap<>();

    public TreeNode buildTree(int[] preorder, int[] inorder) {
        for (int i = 0; i < inorder.length; i++) {
            map.put(inorder[i], i);
        }
        return build(preorder, 0, preorder.length-1, 0);
    }

    private TreeNode build(int[] pre, int preL, int preR, int inL) {
        if (preL > preR)
            return null;
        // preorder第一个元素为root
        TreeNode root = new TreeNode(pre[preL]);
        // 在inorder里面找到root的位置
        int index = map.get(root.val);
        // 左子树的长度
        int leftNum = index - inL;
        // 分别递归得到左右子树
        root.left = build(pre, preL + 1, preL + leftNum, inL);
        root.right = build(pre, preL + leftNum + 1, preR, inL + leftNum + 1);
        return root;
    }
}
```

## [中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

```java
class Solution {
    private HashMap<Integer, Integer> map = new HashMap<>();

    public TreeNode buildTree(int[] inorder, int[] postorder) {
        for (int i = 0; i < inorder.length; i++) 
            map.put(inorder[i], i);
        return build(postorder, postorder.length - 1, 0, inorder.length - 1);
    }

    private TreeNode build(int[] post, int postR, int postL, int inR) {
        if (postR < postL)
            return null;
        TreeNode root = new TreeNode(post[postR]);
        int index = map.get(root.val);
        int rightNum = inR - index;
        root.right = build(post, postR - 1, postR - rightNum, inR);
        root.left = build(post, postR - rightNum - 1, postL, inR - rightNum - 1);
        return root;
    }
}
```

## [层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

```java
// DFS
public static List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> res = new ArrayList<>();
    if (root == null) {
        return res;
    }
    
    dfs(root, res, 0);
    return res;
}

private void dfs(TreeNode root, List<List<Integer>> res, int level) {
    if (root == null) {
        return;
    }
    if (level == res.size()) {
        res.add(new ArrayList<>());
    }
    res.get(level).add(root.val);
    
    dfs(root.left, res, level + 1);
    dfs(root.right, res, level + 1);
}

// BFS
// [
//  [3],
//  [9,20],
//  [15,7]
// ]
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> res = new ArrayList<>();
    if (root == null)
        return res;
    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(root);
    while (!queue.isEmpty()) {
        int cnt = queue.size();
        List<Integer> list = new ArrayList<>();
        while (cnt-- > 0) {
            TreeNode cur = queue.poll();
            list.add(cur.val);
            if (cur.left != null)
                queue.add(cur.left);
            if (cur.right != null)
                queue.add(cur.right);
        }
        res.add(list);
    }
    return res;
}

//输出为数组，[3,9,20,15,7]
public int[] levelOrder(TreeNode root) {
    if (root == null)
        return new int[]{};
    Queue<TreeNode> queue = new LinkedList<>();
    ArrayList<Integer> list = new ArrayList<>();
    queue.add(root);
    while (!queue.isEmpty()) {
        TreeNode node = queue.poll();
        list.add(node.val);
        if (node.left != null)
            queue.add(node.left);
        if (node.right != null)
            queue.add(node.right);
    }
    int[] res = new int[list.size()]; 
    for (int i = 0; i < res.length; i++) {
      res[i] = list.get(i);
    }
    return res;
}
// "Z"字遍历
// [
//   [3],
//   [20,9],
//   [15,7]
// ]
public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
		List<List<Integer>> res = new ArrayList<>();
    if (root == null)
        return res;
		Queue<TreeNode> queue = new LinkedList<>();
    queue.add(root);
    int level = 0;
    while (!queue.isEmpty()) {
        int cnt = queue.size();
        List<Integer> list = new ArrayList<>();
        while (cnt-- > 0) {
            TreeNode node = queue.poll();
            if (level % 2 == 0) {
                list.add(node.val);
             } else {
                list.add(0, node.val);
             }
                
             if (node.left != null)
                queue.add(node.left);
             if (node.right != null)
                queue.add(node.right);
        }
        level++;
        res.add(list);
    }
    return res;
}
```

## [层平均值](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/)

>   给定一个非空二叉树, 返回一个由每层节点平均值组成的数组

```java
class Solution {
    public List<Double> averageOfLevels(TreeNode root) {
        List<Double> res = new ArrayList<>();
        if (root == null)
            return res;
        //BFS
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while (!queue.isEmpty()) {
            int cnt = queue.size();
            double sum = 0;
            for (int i = 0; i < cnt; i++) {
                TreeNode node = queue.poll();
                sum += node.val;
                if (cur.left != null)
                    queue.add(cur.left);
                if (cur.right != null)
                    queue.add(cur.right);
            }
            res.add(sum/cnt);
        }
        return res;
    }
}
```

## [树左下角的值](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)

>   给定一个二叉树，在树的最后一行找到最左边的值。

```java
class Solution {
    public int findBottomLeftValue(TreeNode root) {
        //BFS,从右往左
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while (!queue.isEmpty()) {
            root = queue.poll();
            if (root.right != null) 
                queue.add(root.right);
            if (root.left != null)
                queue.add(root.left);
        }
        return root.val;
    }
}
```

## [翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null)
            return null;
        
        TreeNode node = root.left;
        root.left = root.right;
        root.right = node;

        invertTree(root.left);
        invertTree(root.right);
        return root;
    }
}
```

## [合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)

```java
class Solution {
    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {
        if (t1 == null)
            return t2;
        if (t2 == null) 
            return t1;
       
        t1.val += t2.val;
        t1.left = mergeTrees(t1.left,t2.left);
        t1.right = mergeTrees(t1.right,t2.right);

        return t1;
    }
}
```

##  [对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if (root == null) 
            return true;
        return isSymmetric(root.left,root.right);
    }

    private boolean isSymmetric(TreeNode t1, TreeNode t2) {
        if (t1 == null && t2 == null) return true;
        if (t1 == null || t2 == null) return false;
        if (t1.val != t2.val) return false;
        return isSymmetric(t1.left,t2.right) && isSymmetric(t1.right,t2.left);
    }
}
```

## [另一个树的子树](https://leetcode-cn.com/problems/subtree-of-another-tree/)

```java
class Solution {
    public boolean isSubtree(TreeNode s, TreeNode t) {
        if (s == null)
            return false;
        return isSubtreeFromRoot(s, t) || isSubtree(s.left, t) || isSubtree(s.right, t);
    }

    private boolean isSubtreeFromRoot(TreeNode s, TreeNode t) {
        if (s == null && t == null) return true;
        if (s == null || t == null) return false;
        if (s.val != t.val) return false;
        
        return isSubtreeFromRoot(s.left, t.left) && isSubtreeFromRoot(s.right, t.right);
    }
}
```

## 最大值

```java
public int getMax(TreeNode root) {
    if (root == null) 
        return -1;
    int left = getMax(root.left);
    int right = getMax(root.right);
    return Math.max(Math.max(left, rigth), root.val);
}
```

## [第二小的节点](https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/)

>   如果一个节点有两个子节点的话，那么这个节点的值不大于它的子节点的值。 

```java
class Solution {
    public int findSecondMinimumValue(TreeNode root) {
        return traversal(root, root.val);
    }

    // 求左右子树的最小值
    private int traversal(TreeNode root, int value) {
        if (root == null)
            return -1;
        if (root.val > value)
            return root.val;
        // 寻找左右子节点中，第一个大于自己的节点
        int l = traversal(root.left, value);
        int r = traversal(root.right, value);

        if (l > 0 && r > 0)
            return Math.min(l, r);
        return Math.max(l, r);
    }
}
```

## [最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

```java
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null)
            return 0;
        
        return Math.max(maxDepth(root.left),maxDepth(root.right)) + 1;
    }
}
```

## [最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

```java
class Solution {
    // dfs
    public int minDepth(TreeNode root) {
        if (root == null) return 0;
        int l = minDepth(root.left);
        int r = minDepth(root.right);
        //只有左子树或者只有右子树或者是叶子节点
        if (l == 0 || r == 0)
            return l + r + 1;
        return Math.min(l, r) + 1;
    }
    //一般找最短路径用bfs，不用遍历整棵树
    public int minDepth(TreeNode root) {
        if (root == null) return 0;
        Queue<TreeNode> q = new LinkedList<>();
        q.add(root);
        // root 本身就是一层，depth 初始化为 1
        int depth = 1;

        while (!q.isEmpty()) {
            int cnt = q.size();
            /* 将当前队列中的所有节点向四周扩散 */
            while (cnt-- > 0) {
                TreeNode cur = q.poll();
                /* 判断是否到达终点 */
                if (cur.left == null && cur.right == null) 
                    return depth;
                /* 将 cur 的相邻节点加入队列 */
                if (cur.left != null)
                    q.add(cur.left);
                if (cur.right != null) 
                    q.add(cur.right);
            }
            /* 这里增加步数 */
            depth++;
        }
        return depth;
   }
}
```

## [直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

>   一棵二叉树的直径长度是任意两个结点路径长度中的最大值。

```java
class Solution {
    private int max = 0;
    
    public int diameterOfBinaryTree(TreeNode root) {
        depth(root);
        return max;
    }

    private int depth(TreeNode root) {
        if (root == null) return 0;
        int l = depth(root.left);
        int r = depth(root.right);
        max = Math.max(max,l+r);// 直径
        return Math.max(l,r) + 1;// 树的最大深度
    }
}
```

## [二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

```java
class Solution {
    private int max = Integer.MIN_VALUE;

    public int maxPathSum(TreeNode root) {
        dfs(root);
        return max;    
    }

    private int dfs(TreeNode root) {
        if (root == null) return 0;
        int l = Math.max(dfs(root.left), 0);
        int r = Math.max(dfs(root.right), 0);
        max = Math.max(max, root.val + l + r);
        return Math.max(l, r) + root.val; // 树的单边的最大值
    }
}
```

## [出现次数最多的子树元素和](https://leetcode-cn.com/problems/most-frequent-subtree-sum/)

```java
class Solution {
    private Map<Integer, Integer> map = new HashMap<>();
    private int max; 
    public int[] findFrequentTreeSum(TreeNode root) {
        if (root == null) {
            return new int[0];
        }
        dfs(root);
        List<Integer> list = new ArrayList<>();
        for (Integer key : map.keySet()) {
            if (map.get(key) == max) {
                list.add(key);
            }
        }

        int[] res = new int[list.size()];
        for (int i = 0; i < list.size(); i++) {
            res[i] = list.get(i);
        }
        return res;
    }

    private int dfs(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int left = dfs(root.left);
        int right = dfs(root.right);
        int sum = root.val + left + right;
        if (map.containsKey(sum)) {
            map.put(sum, map.get(sum) + 1);
        } else {
            map.put(sum, 1);
        }
        max = Math.max(max, map.get(sum));
        return sum;
    }
}
```

```c++
class Solution {
public:
    unordered_map<int, int> map;
    int maxFreq = 0;
    vector<int> findFrequentTreeSum(TreeNode* root) {
        dfs(root);
        vector<int> res;
        for (auto &it : map) {
            if(it.second == maxFreq) {
                res.push_back(it.first);
            }
        }
        return res;
    }

    int dfs(TreeNode *root) {
        if (root == nullptr) {
            return 0;
        }
        int left = dfs(root->left);
        int right = dfs(root->right);
        int sum = root->val + left + right;
        map[sum]++;
        maxFreq = max(maxFreq, map[sum]);
        return sum;
    }
};
```

## [平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

> 平衡二叉树每一个节点的左右两个子树的高度差不超过1   

```java
class Solution {
    private boolean isBalanced = true;

    public boolean isBalanced(TreeNode root) {
        depth(root);
        return isBalanced;
    }

    private int depth(TreeNode root) {
        if (root == null) 
            return 0;

        int l = depth(root.left);
        int r = depth(root.right);
        if (Math.abs(l - r) > 1)
            isBalanced = false;
        return Math.max(l,r) + 1;
    }
}
```

## [二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

```java
class Solution {
    private TreeNode pre = null;
    public void flatten(TreeNode root) {
        // 迭代
        // while (root != null) {
        //     if (root.left != null) {
        //         //找左子树最右边的节点
        //         TreeNode node = root.left;
        //         while (node.right != null) {
        //             node = node.right;
        //         }
        //         node.right = root.right;
        //         root.right = root.left;
        //         root.left = null;
        //     }
               // 考虑新的右子树的根节点
        //     root = root.right;
        // }
        
        //后序遍历
        if (root == null)
            return;
        flatten(root.right);
        flatten(root.left);
        root.right = pre;
        root.left = null;
        pre = root;
    }
}
```

## [和为某一值的路径](https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/)

>   输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。

```java
class Solution {
    private List<List<Integer>> res = new ArrayList<>();

    public List<List<Integer>> pathSum(TreeNode root, int sum) {
        //回溯
        backtrack(root, sum, new ArrayList<>());
        return res;
    }

    private void backtrack(TreeNode node, int target, ArrayList<Integer> path) {
        if (node == null)
            return;
        path.add(node.val);
        target -= node.val;
        //结束条件
        if (target == 0 && node.left == null && node.right == null) {
            res.add(new ArrayList<>(path));
        } else {
            backtrack(node.left, target, path);
            backtrack(node.right, target, path);
        }
        // 撤销选择，状态重置
        path.remove(path.size() - 1);
    }
}
```

## [完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)

```java
// O(logN*logN)
public int countNodes(TreeNode root) {
    TreeNode l = root, r = root;
    // 记录左、右子树的高度
    int lh = 0, rh = 0;
    while (l != null) {
        l = l.left;
        lh++;
    }
    while (r != null) {
        r = r.right;
        rh++;
    }
    // 如果左右子树的高度相同，则是一棵满二叉树
    if (hl == hr) {
        return (int)Math.pow(2, lh) - 1;
    }
    // 如果左右高度不同，则按照普通二叉树的逻辑计算
    return countNodes(root.left) + countNodes(root.right) + 1;
}
```



# 二叉搜索树

## [验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

```java
class Solution {
    //中序遍历有序
    private TreeNode preNode = null;
    public boolean isValidBST(TreeNode root) {
        if (root == null)
            return true;
        if (!isValidBST(root.left))
            return false;
      
        if (preNode != null && preNode.val >= root.val)
            return false;
        preNode = root;
      
        if (!isValidBST(root.right))
            return false;
        return true;
    }
}
```

## [第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)

```java
class Solution {
    private int cnt = 0;
    private int res;
    public int kthSmallest(TreeNode root, int k) {
        //中序遍历有序
        inOrder(root, k);
        return res;
    }

    private void inOrder(TreeNode node, int k) {
        if (node == null)
            return;
        inOrder(node.left, k);
        cnt++;
        if (cnt == k) {
            res = node.val;
            return;
        }
        inOrder(node.right, k);
    }
}
```

## [第k大的元素](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

```java
class Solution {
    private int res;
    private int cnt = 0;

    public int kthLargest(TreeNode root, int k) {
        //逆中序遍历有序
        inOrder(root, k);
        return res;
    }

    private void inOrder(TreeNode root, int k) {
        if (root == null)
            return;
        inOrder(root.right, k);
        cnt++;
        if (cnt == k) {
        		res = root.val;
          	return;
        }    
        inOrder(root.left, k);
    }
}
```

## [BST与双向链表](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)

>   将二叉搜索树转换成一个**排序**的**循环**双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。

```java
class Solution {
    private Node head = null, tail = null, pre = null;

    public Node treeToDoublyList(Node root) {
        if (root == null)
            return null;
        //中序遍历访问节点并连接
        inOrder(root);
        //循环链表
        head.left = tail;
        tail.right = head;
        return head;
    }

    private void inOrder(Node node) {
        if (node == null)
            return;
        inOrder(node.left);
      
        if (pre == null) {
            head = node;
        } else {
            pre.right = node;
        }
        node.left = pre;
        pre = node;
        tail = node;
      
        inOrder(node.right);
    }
}
```

## [最小绝对差](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/)

>   计算BST中任意两节点的差的绝对值的最小值。

```java
class Solution {
    private int res = Integer.MAX_VALUE;
    private TreeNode preNode = null;

    public int getMinimumDifference(TreeNode root) {
        inOrder(root);
        return res;
    }

    private void inOrder(TreeNode root) {
        if (root == null)
            return;
        inOrder(root.left);
        if (preNode != null) {
            res = Math.min(res, root.val - preNode.val);
        }
        preNode = root;
        inOrder(root.right);
    }
}
```

## [BST转换为累加树](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)

>   给定一个二叉搜索树，把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。

```java
class Solution {
    private int sum = 0;
    public TreeNode convertBST(TreeNode root) {
        if (root == null)
            return null;
        //逆中序遍历
        convertBST(root.right);
        sum += root.val;
        root.val = sum;
        convertBST(root.left);
        return root;
    }
}
```

## [有序数组转换为BST](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)

>   将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。

```java
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        if (nums == null)
            return null;
        return buildBST(nums, 0, nums.length - 1);
    }

    private TreeNode buildBST(int[] nums, int l, int r) {
        if (l > r)
            return null;
        int m = l + (r - l) / 2;
        TreeNode root = new TreeNode(nums[m]);
        root.left = buildBST(nums, l, m - 1);
        root.right = buildBST(nums, m + 1, r);
        return root;
    }
}
```

## [后序遍历序列](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)

>   输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果

```java
class Solution {
    public boolean verifyPostorder(int[] postorder) {
        if (postorder.length == 0) 
            return true;
        return verify(postorder, 0, postorder.length - 1);
    }

    private boolean verify(int[] post, int l, int r) {
        if (l >= r)
            return true;
        int val = post[r];
        int index = l;
        while (index < r && post[index] < val)
            index++;
        for (int i = index; i < r; i++) {
            if (post[i] < val)
                return false;
        }
        return verify(post, l, index - 1) && verify(post, index, r - 1);
    }
}
```

## [修剪二叉搜索树](https://leetcode-cn.com/problems/trim-a-binary-search-tree/)

>   通过修剪二叉搜索树，使得所有节点的值在`[L, R]`中

```java
class Solution {
    public TreeNode trimBST(TreeNode root, int L, int R) {
        if (root == null)
            return null;
        if (root.val > R)
            return trimBST(root.left, L, R);
        if (root.val < L)
            return trimBST(root.right, L, R);
        root.left = trimBST(root.left, L, R);
        root.right = trimBST(root.right, L, R);
        return root;
    }
}
```

## [BST最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root.val > p.val && root.val > q.val)
            return lowestCommonAncestor(root.left, p, q);
        if (root.val < p.val && root.val < q.val)
            return lowestCommonAncestor(root.right, p, q);
        return root;
    }
}
```

## [二叉树最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null || p == root || q == root)
            return root;
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        if (left != null && right != null)
            return root;
        return left != null ? left : right;
    }
}
```

## [不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)

>   给定一个整数 *n*，求以 1 ... *n* 为节点组成的二叉搜索树有多少种？

```java
class Solution {
    public int numTrees(int n) {
        // 卡特兰数
        int[] dp = new int[n + 1];
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }
        return dp[n];
    }
}
```

## [实现 Trie (前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)

>   实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。
>
>   你可以假设所有的输入都是由小写字母 a-z 构成的。
>   保证所有输入均为非空字符串。

```java
class Trie {

    private class TrieNode {//每个节点最多有26个小写字母 多叉树
        private boolean isWord;
        private TrieNode[] next;

        public TrieNode() {
            isWord = false;
            next = new TrieNode[26];
        }
    }

    private TrieNode root;
    /** Initialize your data structure here. */
    public Trie() {
        root = new TrieNode();
    }
    
    /** Inserts a word into the trie. */
    public void insert(String word) {
        TrieNode cur = root;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null) {
                cur.next[c] = new TrieNode();
            }
            cur = cur.next[c];
        }
        cur.isWord = true;
    }
    
    /** Returns if the word is in the trie. */
    public boolean search(String word) {
        TrieNode cur = root;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null) {
                return false;
            }
            cur = cur.next[c];
        }
        return cur.isWord;
    }
    
    /** Returns if there is any word in the trie that starts with the given prefix. */
    public boolean startsWith(String prefix) {
        TrieNode cur = root;
        for (int i = 0; i < prefix.length(); i++) {
            int c = prefix.charAt(i) - 'a';
            if (cur.next[c] == null) {
                return false;
            }
            cur = cur.next[c];
        }
        return true;
    }

```

## 主元素
给定一个整型数组，找出主元素，它在数组中的出现次数严格大于数组元素个数的二分之一(可以假设数组非空，且数组中总是存在主元素)。
```java
public int majorityNumber(List<Integer> nums) {
    int currentMajor = 0;
    int count = 0;

    for(Integer num : nums) {
        if(count == 0) {
            currentMajor = num;
        }
        
        if(num == currentMajor) {
            count++;
        } else {
            count--;
        }
    }
    return currentMajor;
}
```

# 字符串处理
##  [Excel表列名称](https://leetcode-cn.com/problems/excel-sheet-column-title/)
> 给定一个正整数，返回相应的列标题，如Excel表中所示。如1 -> A，2 -> B...26 -> Z，27 -> AA
```java
public String convertToTitle (int n) {
    StringBuilder sb = new StringBuilder();

    while (n > 0) {
        n--;
        sb.append ( (char) ( (n % 26) + 'A'));
        n /= 26;
    }
    return sb.reverse().toString();
}
```

## [Excel表列序号](https://leetcode-cn.com/problems/excel-sheet-column-number/)

>   A -> 1
>       B -> 2
>       C -> 3
>       ...
>       Z -> 26
>       AA -> 27
>       AB -> 28 
>       ...
>
>   26进制

```java
class Solution {
    public int titleToNumber(String s) {
        int n = s.length();
        char[] arr = s.toCharArray();
        int ret = 0;
        for (int i = 0; i < n; i++) {
            //ret += (arr[i] - 'A' + 1) * Math.pow(26, n - i - 1);
            ret = ret * 26 + arr[i] - 'A' + 1;
        }
        return ret;
    }
}
```

## 翻转游戏

> 翻转游戏：给定一个只包含两种字符的字符串：+和-，你和你的小伙伴轮流翻转"++"变成"--"。当一个人无法采取行动时游戏结束，另一个人将是赢家。编写一个函数，计算字符串在一次有效移动后的所有可能状态。
```java
public List<String> generatePossibleNextMoves (String s) {
    List list = new ArrayList();
    for (int i = -1; (i = s.indexOf ("++", i + 1)) >= 0;) {
        list.add (s.substring (0, i) + "--" + s.substring (i + 2));
    }
    return list;
}
```

## 翻转字符串中的单词
> 给定一个字符串，逐个翻转字符串中的每个单词。
```java
public String reverseWords(String s) {
    if(s.length() == 0 || s == null){
        return " ";
    }
    //按照空格将s切分
    String[] array = s.split(" ");
    StringBuilder sb = new StringBuilder();
    //从后往前遍历array，在sb中插入单词
    for(int i = array.length - 1; i >= 0; i--){
        if(!array[i].equals("")) {
            if (sb.length() > 0) {
                sb.append(" ");
            }
            
            sb.append(array[i]);
        }
    }
    return sb.toString();
}
```

## 最长公共前缀
```java
public String longestCommonPrefix(String[] strs) {
    if (strs == null || strs.length == 0) {
        return "";
    }
    String prefix = strs[0];
    for(int i = 1; i < strs.length; i++) {
        int j = 0;
        while (j < strs[i].length() && j < prefix.length() && strs[i].charAt(j) == prefix.charAt(j)) {
            j++;
        }
        if( j == 0) {
            return "";
        }
        prefix = prefix.substring(0, j);
    }
    return prefix;
}
```

##  [回文数](https://leetcode-cn.com/problems/palindrome-number/)
> 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。
```java
class Solution {
    public boolean isPalindrome(int x) {
        if (x < 0 || x != 0 && x % 10 == 0) 
            return false;
        int rev = 0;
        while (x > rev) {
            rev = rev * 10 + x % 10;
            x /= 10;
        }
        //考虑奇偶数
        return x == rev || x == rev /10;
    }
}
```

# 矩阵

## 螺旋矩阵
> 给定一个包含 m x n 个要素的矩阵，（m 行, n 列），按照螺旋顺序，返回该矩阵中的所有要素。
```java
public List<Integer> spiralOrder(int[][] matrix) {
    ArrayList<Integer> rst = new ArrayList<Integer>();
    if(matrix == null || matrix.length == 0) {
        return rst;
    }
    
    int rows = matrix.length;
    int cols = matrix[0].length;
    int count = 0;
    while(count * 2 < rows && count * 2 < cols){
        for (int i = count; i < cols - count; i++) {
            rst.add(matrix[count][i]);
        }
        
        for (int i = count + 1; i < rows - count; i++) {
            rst.add(matrix[i][cols - count - 1]);
        }
        
        if (rows - 2 * count == 1 || cols - 2 * count == 1) { // 如果只剩1行或1列
            break;
        }
            
        for (int i = cols - count - 2; i >= count; i--) {
            rst.add(matrix[rows - count - 1][i]);
        }
            
        for (int i = rows - count - 2; i >= count + 1; i--) {
            rst.add(matrix[i][count]);
        }
        
        count++;
    }
    return rst;
}
```

## 判断数独是否合法
> 请判定一个数独是否有效。该数独可能只填充了部分数字，其中缺少的数字用 . 表示。  

维护一个HashSet用来记同一行、同一列、同一九宫格是否存在相同数字
```java
public boolean isValidSudoku(char[][] board) {
    Set seen = new HashSet();
    for (int i=0; i<9; ++i) {
        for (int j=0; j<9; ++j) {
            char number = board[i][j];
            if (number != '.')
                if (!seen.add(number + " in row " + i) ||
                    !seen.add(number + " in column " + j) ||
                    !seen.add(number + " in block " + i / 3 + "-" + j / 3))
                    return false;
        }
    }
    return true;
}
```

## [旋转图像](https://leetcode-cn.com/problems/rotate-image/)
> 给定一个N×N的二维矩阵表示图像，90度顺时针旋转图像。
```java
class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        //上下行交换
        for (int i = 0; i < n / 2; i++) {
            for (int j = 0; j < n; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[n - 1 - i][j];
                matrix[n - 1 - i][j] = temp;
            }
        }

        //对角线交换
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < i; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
    }
}
```

# 二进制 / 位运算
## 落单的数
> 给出 2 * n + 1个数字，除其中一个数字之外其他每个数字均出现两次，找到这个数字。

异或运算具有很好的性质，相同数字异或运算后为0，并且具有交换律和结合律，故将所有数字异或运算后即可得到只出现一次的数字。
```java
public int singleNumber(int[] A) {
    if(A == null || A.length == 0) {
        return -1;
    }
    int res = 0;
    for (int i = 0; i < A.length; i++) {
        res ^= A[i];
    }
    return res;
}
```

## [格雷编码](https://leetcode-cn.com/problems/gray-code/)
> 格雷编码是一个二进制数字系统，在该系统中，**两个连续的数值仅有一个位数的差异。**
>
> 给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。即使有多个不同答案，你也只需要返回其中一种。
>
> 格雷编码序列必须以 0 开头。
>

```java
class Solution {
    public List<Integer> grayCode(int n) {
         /**
        关键是搞清楚格雷编码的生成过程, G(i) = i ^ (i/2);
        如 n = 3: 
        G(0) = 000, 
        G(1) = 1 ^ 0 = 001 ^ 000 = 001
        G(2) = 2 ^ 1 = 010 ^ 001 = 011 
        G(3) = 3 ^ 1 = 011 ^ 001 = 010
        G(4) = 4 ^ 2 = 100 ^ 010 = 110
        G(5) = 5 ^ 2 = 101 ^ 010 = 111
        G(6) = 6 ^ 3 = 110 ^ 011 = 101
        G(7) = 7 ^ 3 = 111 ^ 011 = 100
        **/
        List<Integer> res = new ArrayList<>();
        for(int i = 0; i < 1<<n; ++i)
            res.add(i ^ i>>1);
        return res;
    }
}
```

# 其他
## [整数反转](https://leetcode-cn.com/problems/reverse-integer/)

> 将一个整数中的数字进行颠倒，当颠倒后的整数溢出时，返回 0 (标记为 32 位整数)。
```java
class Solution {
    public int reverse(int x) {
        int res = 0;
        while (x != 0) {
            int n = x % 10;
            x /= 10;
            //溢出
            if (res > Integer.MAX_VALUE / 10 || res < Integer.MIN_VALUE / 10) 
                return 0;
            res = res * 10 + n; 
        }
        return res;
    }
}
```

## [字符串转换整数 (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi/)

>   请你来实现一个 `atoi` 函数，使其能将字符串转换成整数

```java
class Solution {
    public int myAtoi(String str) {
        char[] chars = str.toCharArray();
        int n = chars.length;
        int idx = 0;
        while (idx < n && chars[idx] == ' ') {
            // 去掉前导空格
            idx++;
        }
        if (idx == n) {
            //去掉前导空格以后到了末尾了
            return 0;
        }
        boolean negative = false;
        if (chars[idx] == '-') {
            //遇到负号
            negative = true;
            idx++;
        } else if (chars[idx] == '+') {
            // 遇到正号
            idx++;
        } else if (!Character.isDigit(chars[idx])) {
            // 其他符号
            return 0;
        }
        int res = 0;
        while (idx < n && Character.isDigit(chars[idx])) {
            int n = chars[idx] - '0';
            if (ans > (Integer.MAX_VALUE - digit) / 10) {
                return negative ? Integer.MIN_VALUE : Integer.MAX_VALUE;
            }
            res = res * 10 + n;
            idx++;
        }
        return negative ? -res : res;
    }
}
```

## [滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)

>   给定一个数组 `nums` 和滑动窗口的大小 `k`，请找出所有滑动窗口里的最大值。

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        
        if (nums == null || nums.length == 0)
             return new int[]{};
        int[] res = new int[nums.length - k + 1];

        //大顶堆
        // PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> (b - a));
        // for (int i = 0; i < k; i++) {
        //     pq.add(nums[i]);
        // }
        // res[0] = pq.peek();
        // int i = 0, j = k;
        // while (j < nums.length) {
        //     pq.remove(nums[i]);
        //     pq.add(nums[j]);
        //     i++;
        //     j++;
        //     res[i] = pq.peek();
        // }
        // return res;

        //双向队列 单调队列
        LinkedList<Integer> deque = new LinkedList<>();
        for (int i = 0; i < nums.length; i++) {
            while(!deque.isEmpty() && nums[deque.peekLast()] <= nums[i])
                deque.pollLast();
            deque.add(i);

            //判断队首是否还在滑动窗口中
            if (deque.peek() <= i - k) {
                deque.poll();
            }
            
            if (i - k + 1 >= 0) {
                res[i - k + 1] = nums[deque.peek()];
            }
        }
        return res;
    }
}
```

## [LRU缓存](https://leetcode-cn.com/problems/lru-cache/)

> 为最近最少使用（LRU）缓存策略设计一个数据结构，它应该支持以下操作：获取数据（get）和写入数据（put）。
>
> 获取数据get(key)：如果缓存中存在key，则获取其数据值（通常是正数），否则返回-1。 
>
> 写入数据put(key, value)：如果key还没有在缓存中，则写入其数据值。当缓存达到上限，它应该在写入新数据之前删除最近最少使用的数据用来腾出空闲位置。
>
> *   LinkedHashMap

```java
class LRUCache {
    private LinkedHashMap<Integer, Integer> data;  // 保持插入顺序
    private int size;

    public LRUCache(int capacity) {
        data = new LinkedHashMap<>();
        size = capacity;
    }
    public int get(int key) {
        if (!data.containsKey(key)) {
            return -1;
        }
        // 保证每次查询后，都在末尾
        int value = data.remove(key);
        data.put(key, value);
        return value;
    }

    public void put(int key, int value) {
        if (data.containsKey(key)) {
            data.remove(key);
        } else {
            if (data.size() == size) {
                data.remove(data.entrySet().iterator().next().getKey());
            }
        }
        data.put(key, value);
    }
}
```

*   哈希表+双向链表(删除的时间复杂度是O(1)，单向链表要遍历)

```java
class LRUCache {

    class Node {
        public int key, value;
        public Node prev, next;

        public Node(int key, int value) {
            this.key = key;
            this.value = value;
        }
    }

    private class DoubleList {
        Node head, tail;
        private int size;

        public DoubleList() {
            this.head = new Node(0, 0);
            this.tail = new Node(0, 0);
            head.next = tail;
            tail.prev = head;
            size = 0;
        }

        public void addFirst(Node node) {
            node.next = head.next;
            node.prev = head;
            head.next.prev = node;
            head.next = node;
            size++;
        }

        public Node removeLast() {
            if (tail.prev == head)
                return null;
            Node node = tail.prev;
            remove(node);
            return node;
        }

        private void remove(Node node) {
            node.next.prev = node.prev;
            node.prev.next = node.next;
            node.prev = null;
            node.next = null;
            size--;
        }

        public int getSize() {
            return size;
        }
    }

    private DoubleList cache;
    private HashMap<Integer, Node> map;
    private int capacity;

    public LRUCache(int capacity) {
        cache = new DoubleList();
        map = new HashMap<>();
        this.capacity = capacity;
    }
    
    public int get(int key) {
        if (!map.containsKey(key))
            return -1;
        Node node = map.get(key);
        cache.remove(node);
        cache.addFirst(node);
        return node.value;
    }
    
    public void put(int key, int value) {
        Node node = new Node(key, value);
        if (map.containsKey(key)) {
            cache.remove(map.get(key));
            cache.addFirst(node);
            // 更新 map 中对应的数据
            map.put(key, node);
        } else {
            if (capacity == cache.getSize()) {
                // 删除链表最后一个数据
                Node last = cache.removeLast();
                map.remove(last.key);
            }
            cache.addFirst(node);
            map.put(key, node);
        }
    }
}
```

## [LFU缓存](https://leetcode-cn.com/problems/lfu-cache/)

